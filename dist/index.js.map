{"mappings":"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","sources":["src/index.js","src/receiveStorageEvent.ts","src/crud/read.js","src/crud/isAbsent.js","src/crud/unset.js","src/emitStorageEvent.ts","src/crud/update.js"],"sourcesContent":["import { useEffect } from 'react'\n\nimport receiveStorageEvent from './receiveStorageEvent'\n\nimport read from './crud/read'\nimport unset from './crud/unset'\nimport update from './crud/update'\n\n/**\n * Interact with namespaced localStorage \n * \n * Emit storage events to other tabs\n */\nconst useLocalStorage = (namespace, eventCb) => {\n\n  useEffect(() => {\n    const onStore = receiveStorageEvent(eventCb)\n    window.addEventListener(\"storage\", onStore)\n\n    return () => window.removeEventListener(\"storage\", onStore)\n  }, [])\n\n  return {\n     /**\n     * Read a namespace in localStorage or a nested value at that namespace\n     * \n     * @param {unknown} value parsed item value \n     * @param {(string | number)[]} path Ramda Path to nested prop \n     */\n    read: read(namespace),\n     /**\n     * Set a namespace in localStorage or a nested value at that namespace\n     * \n     * Emit the update to other tabs \n     * \n     * @param {unknown} value parsed item value \n     * @param {(string | number)[]} path Ramda Path to set nested prop, or undefined to set namespace\n     */\n    update: update(namespace),\n    /**\n     * Remove a namespace from localStorage or a nested value at that namespace\n     * \n     * @param {(string | number)[] | undefined} path Ramda Path to nested prop  \n     */\n    unset: unset(namespace)\n  }\n}\n\nexport default useLocalStorage","import parse from 'unstring'\n\n/**\n * Update the state of this tab when another tab emits a storage event\n * \n * @param cb callback handed the parsed value of the namespace\n * @param defaultValue T\n * @returns void\n */\nconst receiveStorageEvent = cb => e => {\n  if(typeof cb !== 'function') return \n   \n  if(!e.newValue) {\n    return \n  }  \n\n  const newValue = parse(e.newValue)\n  if (newValue !== undefined) {\n    cb(newValue)\n  }\n}\n\nexport default receiveStorageEvent","import parse from 'unstring'\nimport isAbsent from './isAbsent'\nimport { path } from 'ramda'\n\n/**\n * Read an namespace in localStorage or a nested value at that namespace\n * \n * @param {string} namespace root key of localStorage\n * @param {unknown} value parsed item value \n * @param {(string | number)[] | undefined} path Ramda Path to nested prop \n */\nconst read = namespace => pathToProp => {\n  const stringifiedNamespace = localStorage.getItem(namespace) || ''\n  if(isAbsent(stringifiedNamespace)) return undefined\n  const parsedNamespace = parse(stringifiedNamespace)\n  return isAbsent(pathToProp) ? parsedNamespace : path(pathToProp, parsedNamespace)\n}\n\nexport default read","import { \n  anyPass, \n  isEmpty, \n  isNil\n} from 'ramda'\n\nexport default anyPass([isEmpty, isNil])\n","import emitStorageEvent from '../emitStorageEvent'\nimport read from './read'\nimport update from './update'\n\nimport isAbsent from './isAbsent'\nimport { dissocPath } from 'ramda'\n\n/**\n * Remove a namespace from localStorage or a nested value at that namespace\n * \n * @param {string} namespace root key of localStorage\n * @param {(string | number)[] | undefined} path Ramda Path to nested prop  \n */\nconst unset = namespace => pathToProp => {\n  if(isAbsent(pathToProp)) {\n    localStorage.removeItem(namespace)\n    emitStorageEvent(namespace, null)\n    return \n  }\n  const namespaceValue = read(namespace)()\n  const newNamespaceValue = dissocPath(pathToProp, namespaceValue)\n  update(namespace)(newNamespaceValue)\n}\n\nexport default unset","const emitStorageEvent = (key, stringifiedValue) => {\n  const config = {\n    storageArea: window.localStorage,\n    url: window.location.href,\n    key,\n    newValue: stringifiedValue\n  }\n  \n  const storageEvent = new StorageEvent(\"storage\", config)\n  window.dispatchEvent(storageEvent)\n}\n\nexport default emitStorageEvent","import emitStorageEvent from '../emitStorageEvent'\nimport read from './read'\n\nimport { isNil, lensPath, set } from 'ramda'\n\nconst stringify = value => {\n  try {\n    const stringifiedValue = JSON.stringify(value)\n    return stringifiedValue\n  } catch(e) {\n    return undefined\n  }\n}\n\n/**\n * Set an namespace in localStorage or a nested value at that namespace\n * \n * Emit the update to other tabs \n * \n * @param {string} namespace root key of localStorage\n * @param {unknown} value parsed item value \n * @param {(string | number)[] | undefined} path Ramda Path to nested prop \n */\nconst update = namespace => (value, path) => {\n  const currentNamespace = read(namespace)()\n  const updatedNamespaceValue = isNil(path) ? value : set(lensPath(path), value, currentNamespace)\n  if(!updatedNamespaceValue) return \n  const stringifiedNamespace = stringify(updatedNamespaceValue)\n  localStorage.setItem(namespace, stringifiedNamespace)\n  emitStorageEvent(namespace, stringifiedNamespace)\n}\n\nexport default update"],"names":["useEffect","receiveStorageEvent","read","unset","update","useLocalStorage","namespace","eventCb","onStore","window","addEventListener","removeEventListener","parse","cb","e","newValue","undefined","isAbsent","path","pathToProp","stringifiedNamespace","localStorage","getItem","parsedNamespace","anyPass","isEmpty","isNil","emitStorageEvent","dissocPath","removeItem","namespaceValue","newNamespaceValue","key","stringifiedValue","config","storageArea","url","location","href","storageEvent","StorageEvent","dispatchEvent","lensPath","set","stringify","value","JSON","currentNamespace","updatedNamespaceValue","setItem"],"version":3,"file":"index.js.map"}