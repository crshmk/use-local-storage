{"mappings":";;;;;;ACEA;;;;;;CAMG,GACH,MAAM,4CAAsB,CAAC,KAAkB,CAAC;QAC9C,IAAG,OAAO,OAAO,YAAY;QAE7B,IAAG,CAAC,EAAE,QAAQ,EACZ;QAGF,MAAM,WAAW,CAAA,GAAA,eAAA,EAAM,EAAE,QAAQ;QACjC,IAAI,aAAa,WACf,GAAG;IAEP;IAEA,2CAAe;;;ACtBf;;CAEG;;ACMH,MAAM,iCAAc,CAAA,GAAA,cAAA,EAAQ;IAAC,CAAA,GAAA,cAAA;IAAS,CAAA,GAAA,YAAA;CAAM;IAE5C,2CAAe;;;;ADHf;;;;;;CAMG,GACH,MAAM,6BAAO,CAA4C;IAIvD,OAAO,CAAY;QACjB,MAAM,uBAAuB,aAAa,OAAO,CAAC,cAAc;QAChE,IAAI,CAAA,GAAA,wCAAA,EAAS,uBAAuB,OAAO;QAC3C,MAAM,kBAAkB,CAAA,GAAA,eAAA,EAAM;QAC9B,OAAO,CAAC,aAAa,kBAAkB,CAAA,GAAA,WAAA,EAAgB,YAAoB;IAC/E;AAAC;IAED,2CAAe;;;AGlBf,MAAM,yCAAmB,CAAC,KAAa;IACrC,MAAM,SAA6B;QACjC,aAAa,OAAO,YAAY;QAChC,KAAK,OAAO,QAAQ,CAAC,IAAI;aACzB;QACA,UAAU;IACX;IAED,MAAM,eAAe,IAAI,aAAa,WAAW;IACjD,OAAO,aAAa,CAAC;AACvB;IAEA,2CAAe;;;;;;;;ACbf,MAAM,kCAAY,CAAC;IACjB,IAAI;QACF,MAAM,mBAAmB,KAAK,SAAS,CAAC;QACxC,OAAO;IACT,EAAE,OAAM,GAAG;QACT,OAAO;IACT;AACF;AAEA;;;;;;;;CAQG,GACH,MAAM,+BAAS,CAA4C;IAIzD,OAAO,CAAY,OAAkB;QACnC,MAAM,mBAAmB,CAAA,GAAA,wCAAA,EAAoB;QAC7C,MAAM,wBAAwB,CAAA,GAAA,YAAA,EAAM,QAAQ,QAAQ,CAAA,GAAA,UAAA,EAAI,CAAA,GAAA,eAAA,EAAS,OAAO,OAAO;QAC/E,MAAM,uBAAuB,gCAAU;QACvC,IAAG,CAAA,GAAA,wCAAA,EAAS,uBAAuB;QACnC,aAAa,OAAO,CAAC,WAAW;QAChC,CAAA,GAAA,wCAAA,EAAiB,WAAW;IAC9B;AACF;IAGA,2CAAe;;;;;AFhCf;;;;;CAKG,GACH,MAAM,8BAAQ,CAAC;IAIb,OAAO,CAAC;QACR,IAAG,CAAA,GAAA,wCAAA,EAAS,aAAa;YACvB,aAAa,UAAU,CAAC;YACxB,CAAA,GAAA,wCAAA,EAAiB,WAAW;YAC5B;QACF;QACA,MAAM,iBAAiB,CAAA,GAAA,wCAAA,EAAK;QAC5B,MAAM,oBAAyC,CAAA,GAAA,iBAAA,EAAW,YAAoB;QAC9E,CAAA,GAAA,wCAAA,EAAO,WAAW;IACpB;AACA;IAEA,2CAAe;;;;AJrBf;;;;CAIG,GACH,MAAM,wCAAkB,CAA4C,WAAmB;IAErF,CAAA,GAAA,gBAAA,EAAU;QACR,MAAM,UAAU,CAAA,GAAA,wCAAA,EAAoB;QACpC,OAAO,gBAAgB,CAAC,WAAW;QAEnC,OAAO,IAAM,OAAO,mBAAmB,CAAC,WAAW;IACrD,GAAG,EAAE;IAEL,OAAO;QACJ;;;;;;;;;;;;;;;;;;;;QAoBE,GACH,MAAM,CAAA,GAAA,wCAAA,EAAoB;QAE1B;;;;;;;;;;;;;;;;;;;;SAoBG,GACH,QAAQ,CAAA,GAAA,wCAAA,EAAsB;QAC9B;;;;;;;;;;;;;;;;SAgBG,GACH,OAAO,CAAA,GAAA,wCAAA,EAAM;IACd;AACH;IAEA,2CAAe","sources":["src/index.ts","src/receiveStorageEvent.ts","src/crud/read.ts","src/crud/isAbsent.ts","src/crud/unset.ts","src/emitStorageEvent.ts","src/crud/update.ts"],"sourcesContent":["import { useEffect } from 'react'\n\nimport receiveStorageEvent from './receiveStorageEvent'\n\nimport read from './crud/read'\nimport unset from './crud/unset'\nimport update from './crud/update'\n\n/**\n * Interact with namespaced localStorage \n * \n * Emit storage events to other tabs\n */\nconst useLocalStorage = <NamespaceType extends ParsedObjectOrArray>(namespace: string, eventCb?: Function) => {\n\n  useEffect(() => {\n    const onStore = receiveStorageEvent(eventCb)\n    window.addEventListener('storage', onStore)\n\n    return () => window.removeEventListener('storage', onStore)\n  }, [])\n\n  return {\n     /**\n     * Read a namespace in localStorage or a nested value at that namespace\n     * \n     * @param {unknown} value parsed item value \n     * @param {(string | number)[]} path Ramda Path to nested prop \n     * @returns value in localStorage at path \n     * \n     * @example \n     *   get the value at localStorage.user.preferences.isDarkMode\n     *  ```\n     *   const userStorage = useLocalStorage('user') \n     *  \n     *   userStorage.read<boolean>(['preferences', 'isDarkMode'])\n     * ```\n     * \n     * get the entire user \n     * ```\n     *   userStorage.read()\n     * ```\n     *   \n     */\n    read: read<NamespaceType>(namespace), //as <NamespaceType>(namespace: any) => <ValueType>(pathToProp?: (string | number)[]) => NamespaceType | ValueType | undefined,\n     \n    /**\n     * Set a namespace in localStorage or a nested value at that namespace\n     * \n     * Emit the update to other tabs \n     * \n     * @param {unknown} value parsed item value \n     * @param {(string | number)[]} path Ramda Path to set nested prop, or undefined to set namespace\n     * @return void \n     * @example \n     *   set `user.preferences.isDarkMode`\n     * ```\n     *   const userStorage = useLocalStorage<User>('user') \n     * \n     *   userStorage.update<boolean>(['preferences', 'isDarkMode'], true)\n     * ```\n     * update entire user \n     * ```\n     *   userStorage.update<User>(newUser)\n     * ```\n     * \n     */\n    update: update<NamespaceType>(namespace),\n    /**\n     * Remove a namespace from localStorage or a nested value at that namespace\n     * \n     * @param {(string | number)[] | undefined} path Ramda Path to nested prop  \n     * @example \n     * remove preferences from storage\n     * ```\n     *   const userStorage = useLocalStorage<User>('user') \n     * \n     *   userStorage.unset(['preferences', 'isDarkMode'])\n     * ```\n     * remove the entire user from storage \n     * ```\n     *   userStorage.unset()\n     * ```\n     * \n     */\n    unset: unset(namespace)\n  }\n}\n\nexport default useLocalStorage\n","import parse from 'unstring'\n\n/**\n * Update the state of this tab when another tab emits a storage event\n * \n * @param cb callback handed the parsed value of the namespace\n * @param defaultValue T\n * @returns void\n */\nconst receiveStorageEvent = (cb?: Function) => (e: StorageEvent) => {\n  if(typeof cb !== 'function') return \n   \n  if(!e.newValue) {\n    return \n  }  \n\n  const newValue = parse(e.newValue)\n  if (newValue !== undefined) {\n    cb(newValue)\n  }\n}\n\nexport default receiveStorageEvent","/**\n * TypeScript requires such a mess \n */\nimport parse from 'unstring'\nimport isAbsent from './isAbsent'\nimport { path, Path } from 'ramda'\n\n/**\n * Read an namespace in localStorage or a nested value at that namespace\n * \n * @param {string} namespace root key of localStorage\n * @param {unknown} value parsed item value \n * @param {(string | number)[] | undefined} path Ramda Path to nested prop \n */\nconst read = <NamespaceType extends ParsedObjectOrArray>(namespace: string): {\n  (): NamespaceType | undefined\n  <ValueType>(pathToProp: Path): ValueType | undefined\n} => {\n  return <ValueType>(pathToProp?: Path) => {\n    const stringifiedNamespace = localStorage.getItem(namespace) || ''\n    if (isAbsent(stringifiedNamespace)) return undefined\n    const parsedNamespace = parse(stringifiedNamespace) as NamespaceType\n    return !pathToProp ? parsedNamespace : path<ValueType>(pathToProp as Path, parsedNamespace)\n}}\n\nexport default read \n\n\n","import { \n  anyPass, \n  isEmpty, \n  isNil\n} from 'ramda'\n\ntype T = (x: unknown) => boolean\n\nconst isAbsent: T = anyPass([isEmpty, isNil])\n\nexport default isAbsent\n","import emitStorageEvent from '../emitStorageEvent'\nimport read from './read'\nimport update from './update'\n\nimport isAbsent from './isAbsent'\nimport { dissocPath, Path } from 'ramda'\n\n/**\n * Remove a namespace from localStorage or a nested value at that namespace\n * \n * @param {string} namespace root key of localStorage\n * @param {(string | number)[] | undefined} path Ramda Path to nested prop  \n */\nconst unset = (namespace: string): {\n  (): void \n  (pathToProp?: Path): void \n} => {\n  return (pathToProp?: Path) => {\n  if(isAbsent(pathToProp)) {\n    localStorage.removeItem(namespace)\n    emitStorageEvent(namespace, null)\n    return \n  }\n  const namespaceValue = read(namespace)()\n  const newNamespaceValue: ParsedObjectOrArray = dissocPath(pathToProp as Path, namespaceValue)\n  update(namespace)(newNamespaceValue)\n}\n}\n\nexport default unset","type StorageEventConfig = {\n  storageArea: Storage \n  url: string \n  key: string \n  newValue?: string | null\n}\n\nconst emitStorageEvent = (key: string, stringifiedValue?: string | null) => {\n  const config: StorageEventConfig = {\n    storageArea: window.localStorage,\n    url: window.location.href,\n    key,\n    newValue: stringifiedValue\n  }\n  \n  const storageEvent = new StorageEvent(\"storage\", config)\n  window.dispatchEvent(storageEvent)\n}\n\nexport default emitStorageEvent","import emitStorageEvent from '../emitStorageEvent'\nimport read from './read'\n\nimport { isNil, lensPath, set, Path } from 'ramda'\nimport isAbsent from './isAbsent'\n\nconst stringify = (value: unknown) => {\n  try {\n    const stringifiedValue = JSON.stringify(value)\n    return stringifiedValue\n  } catch(e) {\n    return undefined\n  }\n}\n\n/**\n * Set an namespace in localStorage or a nested value at that namespace\n * \n * Emit the update to other tabs \n * \n * @param {string} namespace root key of localStorage\n * @param {unknown} value parsed item value \n * @param {(string | number)[] | undefined} path Ramda Path to nested prop \n */\nconst update = <NamespaceType extends ParsedObjectOrArray>(namespace: string): {\n  (value: NamespaceType): void\n  <ValueType>(value: ValueType, path: Path): void\n} => {\n  return <ValueType>(value: ValueType, path?: Path): void => {\n    const currentNamespace = read<NamespaceType>(namespace)()\n    const updatedNamespaceValue = isNil(path) ? value : set(lensPath(path), value, currentNamespace)\n    const stringifiedNamespace = stringify(updatedNamespaceValue)\n    if(isAbsent(stringifiedNamespace)) return \n    localStorage.setItem(namespace, stringifiedNamespace)\n    emitStorageEvent(namespace, stringifiedNamespace)\n  }\n}\n \n\nexport default update"],"names":[],"version":3,"file":"index.js.map"}