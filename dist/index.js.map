{"mappings":"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","sources":["src/index.ts","src/receiveStorageEvent.ts","src/parse/index.ts","src/parse/isObjectOrArray.ts","src/crud/read.ts","src/crud/isAbsent.ts","src/crud/unset.ts","src/emitStorageEvent.ts","src/crud/update.ts","src/stringify.ts"],"sourcesContent":["import { useEffect } from 'react'\n\nimport receiveStorageEvent from './receiveStorageEvent'\n\nimport read from './crud/read'\nimport unset from './crud/unset'\nimport update from './crud/update'\n\n/**\n * Interact with namespaced localStorage \n * \n * Emit storage events to other tabs\n */\nconst useLocalStorage = <NamespaceType extends ParsedObjectOrArray>(namespace: string, onStorageCb?: (newValue: NamespaceType) => any , emptyValue: ParsedObjectOrArray | undefined={}) => {\n\n  useEffect(() => {\n    if(!onStorageCb) return \n    const onStorage = receiveStorageEvent(namespace, onStorageCb, emptyValue)\n    window.addEventListener('storage', onStorage)\n\n    return () => window.removeEventListener('storage', onStorage)\n  }, [])\n\n  return {\n     /**\n     * Read a namespace in localStorage or a nested value at that namespace\n     * \n     * @param {unknown} value parsed item value \n     * @param {(string | number)[]} path Ramda Path to nested prop \n     * @returns value in localStorage at path \n     * \n     * @example \n     *   get the value at localStorage.user.preferences.isDarkMode\n     *  ```\n     *   const userStorage = useLocalStorage('user') \n     *  \n     *   userStorage.read<boolean>(['preferences', 'isDarkMode'])\n     * ```\n     * \n     * get the entire user \n     * ```\n     *   userStorage.read()\n     * ```\n     *   \n     */\n    read: read<NamespaceType>(namespace), //as <NamespaceType>(namespace: any) => <ValueType>(pathToProp?: (string | number)[]) => NamespaceType | ValueType | undefined,\n     \n    /**\n     * Set a namespace in localStorage or a nested value at that namespace\n     * \n     * Emit the update to other tabs \n     * \n     * @param {unknown} value parsed item value \n     * @param {(string | number)[]} path Ramda Path to set nested prop, or undefined to set namespace\n     * @return void \n     * @example \n     *   set `user.preferences.isDarkMode`\n     * ```\n     *   const userStorage = useLocalStorage<User>('user') \n     * \n     *   userStorage.update<boolean>(['preferences', 'isDarkMode'], true)\n     * ```\n     * update entire user \n     * ```\n     *   userStorage.update<User>(newUser)\n     * ```\n     * \n     */\n    update: update<NamespaceType>(namespace),\n    /**\n     * Remove a namespace from localStorage or a nested value at that namespace\n     * \n     * @param {(string | number)[] | undefined} path Ramda Path to nested prop  \n     * @example \n     * remove preferences from storage\n     * ```\n     *   const userStorage = useLocalStorage<User>('user') \n     * \n     *   userStorage.unset(['preferences', 'isDarkMode'])\n     * ```\n     * remove the entire user from storage \n     * ```\n     *   userStorage.unset()\n     * ```\n     * \n     */\n    unset: unset(namespace)\n  }\n}\n\nexport default useLocalStorage\n","import parse from './parse'\n\n/**\n * Update the state of this tab when another tab emits a storage event\n * \n * @param cb callback handed the parsed value of the namespace\n * @param defaultValue T\n * @returns void\n */\nconst receiveStorageEvent = (namespace: string, onStorageCb: Function, emptyValue:ParsedObjectOrArray ) => (e: StorageEvent) => {\n  const isStorageEventForThisNamespace = e.key === namespace\n  if(!isStorageEventForThisNamespace) return \n  const newValue = !e.newValue ? emptyValue : parse(e.newValue)\n  onStorageCb(newValue)\n}\n\nexport default receiveStorageEvent","import isObjectOrArray from './isObjectOrArray'\n\n/**\n * Safely parse jason without explicit try / catch\n * \n * Always returns an object or array\n * - primitives, null, etc return an empty object \n * - malformed objects return an empty object \n * - malfomred arrays return an empty array\n * \n * @param json \n * @returns object or array\n */\nconst parse: (json: string) => ParsedObjectOrArray = json => {\n\n  let parsed: ParsedObjectOrArray = {}\n\n  try {\n    parsed = JSON.parse(json)\n    return isObjectOrArray(parsed) ? parsed : {}\n  } catch(e) {    \n    if(typeof json === 'string' && json.length > 0 && json.charAt(0) === '[') {\n      return []\n    }\n    return parsed \n  }\n}\n\nexport default parse ","// value !== value -> NaN check\n\n/**\n * Excludes the following from parsing:\n *  string, number, boolean, null, undefined, symbol NaN, function, bigint.\n * \n * Approves objects and arrays for parsing\n * \n * @param value any\n * @returns boolean \n */\nconst isObjectOrArray = (value: any): boolean =>\n  typeof value === 'object' && value !== null\n\nexport default isObjectOrArray\n","/**\n * TypeScript requires such a mess \n */\nimport isAbsent from './isAbsent'\nimport parse from '../parse'\nimport { path, Path } from 'ramda'\n\n/**\n * Read an namespace in localStorage or a nested value at that namespace\n * \n * @param {string} namespace root key of localStorage\n * @param {unknown} value parsed item value \n * @param {(string | number)[] | undefined} path Ramda Path to nested prop \n */\nconst read = <NamespaceType extends ParsedObjectOrArray>(namespace: string): {\n  (): NamespaceType | undefined\n  <ValueType>(pathToProp: Path): ValueType | undefined\n} => {\n  return <ValueType>(pathToProp?: Path) => {\n    const stringifiedNamespace = localStorage.getItem(namespace) || ''\n    if (isAbsent(stringifiedNamespace)) return undefined\n    const parsedNamespace = parse(stringifiedNamespace) as NamespaceType\n    return !pathToProp ? parsedNamespace : path<ValueType>(pathToProp as Path, parsedNamespace)\n}}\n\nexport default read \n\n\n","import { \n  anyPass, \n  isEmpty, \n  isNil\n} from 'ramda'\n\ntype T = (x: unknown) => boolean\n\nconst isAbsent: T = anyPass([isEmpty, isNil])\n\nexport default isAbsent\n","import emitStorageEvent from '../emitStorageEvent'\nimport read from './read'\nimport update from './update'\n\nimport isAbsent from './isAbsent'\nimport { dissocPath, Path } from 'ramda'\n\nimport stringify from '../stringify'\n\n/**\n * Remove a namespace from localStorage or a nested value at that namespace\n * \n * @param {string} namespace root key of localStorage\n * @param {(string | number)[] | undefined} path Ramda Path to nested prop  \n */\nconst unset = (namespace: string): {\n  (): void \n  (pathToProp?: Path): void \n} => {\n  return (pathToProp?: Path) => {\n  if(isAbsent(pathToProp)) {\n    localStorage.removeItem(namespace)\n    emitStorageEvent(namespace)\n    return \n  }\n  const namespaceValue = read(namespace)()\n  const newNamespaceValue = dissocPath<ParsedObjectOrArray>(pathToProp as Path, namespaceValue)\n  update(namespace)(newNamespaceValue)\n}\n}\n\nexport default unset","type StorageEventConfig = {\n  storageArea: Storage \n  url: string \n  key: string \n  newValue?: string | null\n}\n\nconst emitStorageEvent = (key: string, stringifiedValue?: string) => {\n  const newValue = !stringifiedValue ? null : stringifiedValue\n  const config: StorageEventConfig = {\n    storageArea: window.localStorage,\n    url: window.location.href,\n    key,\n    newValue \n  }\n  \n  const storageEvent = new StorageEvent(\"storage\", config)\n  window.dispatchEvent(storageEvent)\n}\n\nexport default emitStorageEvent","import emitStorageEvent from '../emitStorageEvent'\nimport read from './read'\n\nimport { isNil, lensPath, set, Path } from 'ramda'\nimport isAbsent from './isAbsent'\nimport stringify from '../stringify'\n\n/**\n * Set an namespace in localStorage or a nested value at that namespace\n * \n * Emit the update to other tabs \n * \n * @param {string} namespace root key of localStorage\n * @param {unknown} value parsed item value \n * @param {(string | number)[] | undefined} path Ramda Path to nested prop \n */\nconst update = <NamespaceType extends ParsedObjectOrArray>(namespace: string): {\n  (value: NamespaceType): void\n  <ValueType>(value: ValueType, path: Path): void\n} => {\n  return <ValueType>(value: ValueType, path?: Path): void => {\n    const currentNamespace = read<NamespaceType>(namespace)()\n    const updatedNamespaceValue = isNil(path) ? value : set(lensPath(path), value, currentNamespace)\n    const stringifiedNamespace = stringify(updatedNamespaceValue)\n    if(!stringifiedNamespace) return \n    localStorage.setItem(namespace, stringifiedNamespace)\n    emitStorageEvent(namespace, stringifiedNamespace)\n  }\n}\n \n\nexport default update","const stringify = (value: unknown) => {\n  try {\n    const stringifiedValue = JSON.stringify(value)\n    return stringifiedValue\n  } catch(e) {\n    return undefined\n  }\n}\n\nexport default stringify"],"names":[],"version":3,"file":"index.js.map"}