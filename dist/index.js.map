{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;A,O,c,C,gB,c;I,O;A;A,e,O,G,K;;A,I,kC,6C;AAQG,SAAA,6CAAA,CAAA;IAAA,OAAA,KAAA,EAAA,UAAA,GAAA,IAAA;QAAA,SAAA;IAAA;AAAA;AACH;;;;;;CAOE,GAEE,MAAA,4CAAA,CAAA,KAAA,CAAA;QACF,IAAA,OAAA,OAAA,YAAA;QACD,IAAD,CAAA,EAAA,QAAA,EAEA;Q,M,W,A,C,G,gC,O,A,E,E,Q;Q,I,a,W,G;I;A,I,iC,e,O,G;;;;;ACtBA;AAEG,OAAA,cAAA,CAAA,gBAAA,cAAA;IACH,OAAO;AACP;AACA,eAAO,OAAc,GAAA,KAAM;;AAE3B,IAAA,kCAAA,6CAAA;;A,I,kC,6C;;A,S,6C,C;I,O,K,E,U,G,I;Q,S;I;A;A;;CAMG,GAKD;;;;;;CAKF,GAEA,MAAA,6BAAA,CAAA;I,O,C;Q,M,uB,a,O,C,c;Q,I,A,C,G,gC,O,A,E,uB,O;Q,M,kB,A,C,G,gC,O,A,E;Q,O,C,a,kB,A,C,G,W,E,Y;I;A;A,I,iC,e,O,G;;;;ACzBA;AAUA,OAAA,cAAe,CAAA,gBAAf,cAAA;I,O;A;A,e,O,G,K;;A,M,iC,A,C,G,c,E;I;I;C;A,I,iC,e,O,G;;;;;;ACVA;AAEA,OAAO,cAAY,CAAA,gBAAnB,cAAA;IAEA,OAAO;AACP;AAEA,eAAA,OAAA,GAAA,KAAA;;A,I,0C,6C;;A,I,8B,6C;;A,I,gC,6C;;A,I,kC,6C;;AAMA,SAAM,6CAAgC,CAAA;IAAA,OAAqB,KAA3D,EAAA,UAAA,GAAA,IAAA;QAAA,SAAA;IAAA;AAAA;AACE;;;;;CAKA,GAEA,MAAA,8BAAO,CAAA,YAAW,CAAA;QACnB,IAAD,AAAA,CAAA,GAAA,gCAAA,OAAA,AAAA,EAAA,aAAA;YAEA,aAAe,UAAf,CAAA;Y,C,G,wC,O,A,E,W;Y;Q;Q,M,iB,A,C,G,4B,O,A,E;Q,M,oB,A,C,G,iB,E,Y;Q,C,G,8B,O,A,E,W;I;A,I,iC,e,O,G;;;;ACjBA;AAEI,OAAA,cAAa,CAAA,gBAAO,cAApB;IACA,OAAA;AACA;AACA,eAAA,OAAA,GAAU,KAAA;AACX,MAAA,yCAAA,CAAA,KAAA;IAED,MAAA,SAAM;QACN,aAAO,OAAa,YAAC;QACvB,KAAA,OAAA,QAAA,CAAA,IAAA;aAEA;Q,U;I;I,M,e,I,a,W;I,O,a,C;A;A,I,iC,e,O,G;;;;;ACnBA;AAGA,OAAO,cAAS,CAAA,gBAAqB,cAAa;IAClD,OAAO;AAEP;AACE,eAAI,OAAJ,GAAA,KAAA;;AACE,IAAA,0CAAM,6CAAiC;;AACvC,IAAA,8BAAA,6CAAA;;;AACA,IAAA,kCAAA,6CAAA;AACA,SAAA,6CAAA,CAAA;IAAA,OAAA,KAAA,EAAA,UAAA,GAAA,IAAA;QAAA,SAAA;IAAA;AAAA;AACF,MAAA,kCAAA,CAAA;IACD,IAAD;QAEA,MAAA,mBAAA,KAAA,SAAA,CAAA;Q,O;I,E,O,G;Q,O;I;A;A;;;;;;;;CAcE,GAEF,MAAA,+BAAA,CAAA,YAAA,CAAA,OAAA;QAEA,MAAA,mBAAA,AAAA,CAAA,GAAA,4BAAA,OAAA,AAAA,EAAA;Q,M,wB,A,C,G,Y,E,Q,Q,A,C,G,U,E,A,C,G,e,E,O,O;Q,M,uB,gC;Q,I,A,C,G,gC,O,A,E,uB;Q,a,O,C,W;Q,C,G,wC,O,A,E,W;I;A,I,iC,e,O,G;;;;;;ACjCA;AAIA,OAAO,cAAU,CAAA,2BAAa,cAA9B;IACA,OAAO;AACP;AAEA,0BAAA,OAAA,GAAA,KAAA;;;A,I,6C,6C;;A,I,8B,6C;;AAIG,IAAA,+BAAA,6CAAA;;AACH,IAAA,gCAAM,6CAAiF;AAErF,SAAA,6CAAA,CAAA;IAAA,OAAA,KAAA,EAAA,UAAA,GAAA,IAAA;QAAA,SAAA;IAAA;AAAA;AACE;;;;CAMF,G,M,wC,C,W;I,C,G,gB,E;Q,M,U,A,C,G,2C,O,A,E;Q,O,gB,C,W;Q,O,I,O,mB,C,W;I,G,E;I,O;Q;;;;;;;;;;;;;;;;;;;;I,G,M,A,C,G,4B,O,A,E;Q,+H;Q;;;;;;;;;;;;;;;;;;;;K,G,Q,A,C,G,8B,O,A,E;Q;;;;;;;;;;;;;;;;K,G,O,A,C,G,6B,O,A,E;I;A;A,I,iC,0B,O,G","sources":["src/receiveStorageEvent.ts","src/crud/read.ts","src/crud/isAbsent.ts","src/crud/unset.ts","src/emitStorageEvent.ts","src/crud/update.ts","src/index.ts"],"sourcesContent":["import parse from 'unstring'\n\n/**\n * Update the state of this tab when another tab emits a storage event\n * \n * @param cb callback handed the parsed value of the namespace\n * @param defaultValue T\n * @returns void\n */\nconst receiveStorageEvent = (cb?: Function) => (e: StorageEvent) => {\n  if(typeof cb !== 'function') return \n   \n  if(!e.newValue) {\n    return \n  }  \n\n  const newValue = parse(e.newValue)\n  if (newValue !== undefined) {\n    cb(newValue)\n  }\n}\n\nexport default receiveStorageEvent","/**\n * TypeScript requires such a mess \n */\nimport parse from 'unstring'\nimport isAbsent from './isAbsent'\nimport { path, Path } from 'ramda'\n\n/**\n * Read an namespace in localStorage or a nested value at that namespace\n * \n * @param {string} namespace root key of localStorage\n * @param {unknown} value parsed item value \n * @param {(string | number)[] | undefined} path Ramda Path to nested prop \n */\nconst read = <NamespaceType extends ParsedObjectOrArray>(namespace: string): {\n  (): NamespaceType | undefined\n  <ValueType>(pathToProp: Path): ValueType | undefined\n} => {\n  return <ValueType>(pathToProp?: Path) => {\n    const stringifiedNamespace = localStorage.getItem(namespace) || ''\n    if (isAbsent(stringifiedNamespace)) return undefined\n    const parsedNamespace = parse(stringifiedNamespace) as NamespaceType\n    return !pathToProp ? parsedNamespace : path<ValueType>(pathToProp as Path, parsedNamespace)\n}}\n\nexport default read \n\n\n","import { \n  anyPass, \n  isEmpty, \n  isNil\n} from 'ramda'\n\ntype T = (x: unknown) => boolean\n\nconst isAbsent: T = anyPass([isEmpty, isNil])\n\nexport default isAbsent\n","import emitStorageEvent from '../emitStorageEvent'\nimport read from './read'\nimport update from './update'\n\nimport isAbsent from './isAbsent'\nimport { dissocPath, Path } from 'ramda'\n\n/**\n * Remove a namespace from localStorage or a nested value at that namespace\n * \n * @param {string} namespace root key of localStorage\n * @param {(string | number)[] | undefined} path Ramda Path to nested prop  \n */\nconst unset = (namespace: string) => (pathToProp?: Path) => {\n  if(isAbsent(pathToProp)) {\n    localStorage.removeItem(namespace)\n    emitStorageEvent(namespace, null)\n    return \n  }\n  const namespaceValue = read(namespace)()\n  const newNamespaceValue = dissocPath(pathToProp as Path, namespaceValue)\n  update(namespace)(newNamespaceValue)\n}\n\nexport default unset","type StorageEventConfig = {\n  storageArea: Storage \n  url: string \n  key: string \n  newValue?: string | null\n}\n\nconst emitStorageEvent = (key: string, stringifiedValue?: string | null) => {\n  const config: StorageEventConfig = {\n    storageArea: window.localStorage,\n    url: window.location.href,\n    key,\n    newValue: stringifiedValue\n  }\n  \n  const storageEvent = new StorageEvent(\"storage\", config)\n  window.dispatchEvent(storageEvent)\n}\n\nexport default emitStorageEvent","import emitStorageEvent from '../emitStorageEvent'\nimport read from './read'\n\nimport { isNil, lensPath, set, Path } from 'ramda'\nimport isAbsent from './isAbsent'\n\nconst stringify = (value: unknown) => {\n  try {\n    const stringifiedValue = JSON.stringify(value)\n    return stringifiedValue\n  } catch(e) {\n    return undefined\n  }\n}\n\n/**\n * Set an namespace in localStorage or a nested value at that namespace\n * \n * Emit the update to other tabs \n * \n * @param {string} namespace root key of localStorage\n * @param {unknown} value parsed item value \n * @param {(string | number)[] | undefined} path Ramda Path to nested prop \n */\nconst update = <NamespaceType extends ParsedObjectOrArray>(namespace: string) => <ValueType>(value: ValueType, path?: Path): void => {\n  const currentNamespace = read<NamespaceType>(namespace)<NamespaceType>()\n  const updatedNamespaceValue = isNil(path) ? value : set(lensPath(path), value, currentNamespace)\n  const stringifiedNamespace = stringify(updatedNamespaceValue)\n  if(isAbsent(stringifiedNamespace)) return \n  localStorage.setItem(namespace, stringifiedNamespace as string)\n  emitStorageEvent(namespace, stringifiedNamespace)\n}\n\nexport default update","import { useEffect } from 'react'\n\nimport receiveStorageEvent from './receiveStorageEvent'\n\nimport read from './crud/read'\nimport unset from './crud/unset'\nimport update from './crud/update'\n\n/**\n * Interact with namespaced localStorage \n * \n * Emit storage events to other tabs\n */\nconst useLocalStorage = <NamespaceType extends ParsedObjectOrArray>(namespace: string, eventCb?: Function) => {\n\n  useEffect(() => {\n    const onStore = receiveStorageEvent(eventCb)\n    window.addEventListener('storage', onStore)\n\n    return () => window.removeEventListener('storage', onStore)\n  }, [])\n\n  return {\n     /**\n     * Read a namespace in localStorage or a nested value at that namespace\n     * \n     * @param {unknown} value parsed item value \n     * @param {(string | number)[]} path Ramda Path to nested prop \n     * @returns value in localStorage at path \n     * \n     * @example \n     *   get the value at localStorage.user.preferences.isDarkMode\n     *  ```\n     *   const userStorage = useLocalStorage('user') \n     *  \n     *   userStorage.read<boolean>(['preferences', 'isDarkMode'])\n     * ```\n     * \n     * get the entire user \n     * ```\n     *   userStorage.read()\n     * ```\n     *   \n     */\n    read: read<NamespaceType>(namespace), //as <NamespaceType>(namespace: any) => <ValueType>(pathToProp?: (string | number)[]) => NamespaceType | ValueType | undefined,\n     \n    /**\n     * Set a namespace in localStorage or a nested value at that namespace\n     * \n     * Emit the update to other tabs \n     * \n     * @param {unknown} value parsed item value \n     * @param {(string | number)[]} path Ramda Path to set nested prop, or undefined to set namespace\n     * @return void \n     * @example \n     *   set `user.preferences.isDarkMode`\n     * ```\n     *   const userStorage = useLocalStorage<User>('user') \n     * \n     *   userStorage.update<boolean>(['preferences', 'isDarkMode'], true)\n     * ```\n     * update entire user \n     * ```\n     *   userStorage.update<User>(newUser)\n     * ```\n     * \n     */\n    update: update<NamespaceType>(namespace),\n    /**\n     * Remove a namespace from localStorage or a nested value at that namespace\n     * \n     * @param {(string | number)[] | undefined} path Ramda Path to nested prop  \n     * @example \n     * remove preferences from storage\n     * ```\n     *   const userStorage = useLocalStorage<User>('user') \n     * \n     *   userStorage.unset(['preferences', 'isDarkMode'])\n     * ```\n     * remove the entire user from storage \n     * ```\n     *   userStorage.unset()\n     * ```\n     * \n     */\n    unset: unset(namespace)\n  }\n}\n\nexport default useLocalStorage"],"names":[],"version":3,"file":"index.js.map"}