{"mappings":";;;;;;;;;;ACEA;;;;;;CAMC,GACD,MAAM,4CAAsB,CAAA,KAAM,CAAA;QAChC,IAAG,OAAO,OAAO,YAAY;QAE7B,IAAG,CAAC,EAAE,QAAQ,EACZ;QAGF,MAAM,WAAW,CAAA,GAAA,yCAAI,EAAE,EAAE,QAAQ;QACjC,GAAG;IACL;IAEA,2CAAe;;;;;IEdf,2CAAe,CAAA,GAAA,oBAAM,EAAE;IAAC,CAAA,GAAA,oBAAM;IAAG,CAAA,GAAA,kBAAI;CAAE;;;ADHvC;;;;;;CAMC,GACD,MAAM,6BAAO,CAAA,YAAa,CAAA;QACxB,MAAM,uBAAuB,aAAa,OAAO,CAAC,cAAc;QAChE,IAAG,CAAA,GAAA,wCAAO,EAAE,uBAAuB,OAAO;QAC1C,MAAM,kBAAkB,CAAA,GAAA,yCAAI,EAAE;QAC9B,OAAO,CAAA,GAAA,wCAAO,EAAE,cAAc,kBAAkB,KAAK,YAAY;IACnE;IAEA,2CAAe;;;AGjBf;;;;;;;AAOA,GAEA,MAAM,yCAAmB,CAAC,KAAK;IAC7B,MAAM,SAAS;QACb,aAAa,OAAO,YAAY;QAChC,KAAK,OAAO,QAAQ,CAAC,IAAI;aACzB;QACA,UAAU;IACZ;IAEA,MAAM,eAAe,IAAI,aAAa,WAAW;IACjD,OAAO,aAAa,CAAC;AACvB;IAEA,2CAAe;;;;;;;ACjBf,MAAM,kCAAY,CAAA;IAChB,IAAI;QACF,MAAM,mBAAmB,KAAK,SAAS,CAAC;QACxC,OAAO;IACT,EAAE,OAAM,GAAG;QACT,OAAO;IACT;AACF;AAEA;;;;;;;;CAQC,GACD,MAAM,+BAAS,CAAA,YAAa,CAAC,OAAO;QAClC,MAAM,mBAAmB,CAAA,GAAA,wCAAG,EAAE;QAC9B,MAAM,wBAAwB,CAAA,GAAA,kBAAI,EAAE,QAAQ,QAAQ,CAAA,GAAA,gBAAE,EAAE,CAAA,GAAA,qBAAO,EAAE,OAAO,OAAO;QAC/E,MAAM,uBAAuB,gCAAU;QACvC,aAAa,OAAO,CAAC,WAAW;QAChC,CAAA,GAAA,wCAAe,EAAE,WAAW;IAC9B;IAEA,2CAAe;;;;;AFvBf;;;;;CAKC,GACD,MAAM,8BAAQ,CAAA,YAAa,CAAA;QACzB,IAAG,CAAA,GAAA,wCAAO,EAAE,aAAa;YACvB,aAAa,UAAU,CAAC;YACxB,CAAA,GAAA,wCAAe,EAAE,WAAW;YAC5B;QACF;QACA,MAAM,iBAAiB,CAAA,GAAA,wCAAG,EAAE;QAC5B,MAAM,oBAAoB,CAAA,GAAA,uBAAS,EAAE,YAAY;QACjD,CAAA,GAAA,wCAAK,EAAE,WAAW;IACpB;IAEA,2CAAe;;;;AJhBf;;;;CAIC,GACD,MAAM,wCAAkB,CAAC,WAAW;IAElC,CAAA,GAAA,sBAAQ,EAAE;QACR,MAAM,UAAU,CAAA,GAAA,wCAAkB,EAAE;QACpC,OAAO,gBAAgB,CAAC,WAAW;QAEnC,OAAO,IAAM,OAAO,mBAAmB,CAAC,WAAW;IACrD,GAAG,EAAE;IAEL,OAAO;QACJ;;;;;KAKA,GACD,MAAM,CAAA,GAAA,wCAAG,EAAE;QACV;;;;;;;KAOA,GACD,QAAQ,CAAA,GAAA,wCAAK,EAAE;QACf;;;;KAIC,GACD,OAAO,CAAA,GAAA,wCAAI,EAAE;IACf;AACF;AAEA,iBAAiB","sources":["src/index.js","src/receiveStorageEvent.ts","src/crud/read.js","src/crud/isAbsent.js","src/crud/unset.js","src/emitStorageEvent.ts","src/crud/update.js"],"sourcesContent":["import { useEffect } from 'react'\n\nimport receiveStorageEvent from './receiveStorageEvent'\n\nimport read from './crud/read'\nimport unset from './crud/unset'\nimport update from './crud/update'\n\n/**\n * Interact with namespaced localStorage \n * \n * Emit storage events to other tabs\n */\nconst useLocalStorage = (namespace, eventCb) => {\n\n  useEffect(() => {\n    const onStore = receiveStorageEvent(eventCb)\n    window.addEventListener(\"storage\", onStore)\n\n    return () => window.removeEventListener(\"storage\", onStore)\n  }, [])\n\n  return {\n     /**\n     * Read a namespace in localStorage or a nested value at that namespace\n     * \n     * @param {unknown} value parsed item value \n     * @param {(string | number)[]} path Ramda Path to nested prop \n     */\n    read: read(namespace),\n     /**\n     * Set a namespace in localStorage or a nested value at that namespace\n     * \n     * Emit the update to other tabs \n     * \n     * @param {unknown} value parsed item value \n     * @param {(string | number)[]} path Ramda Path to set nested prop, or undefined to set namespace\n     */\n    update: update(namespace),\n    /**\n     * Remove a namespace from localStorage or a nested value at that namespace\n     * \n     * @param {(string | number)[] | undefined} path Ramda Path to nested prop  \n     */\n    unset: unset(namespace)\n  }\n}\n\nmodule.exports = useLocalStorage","import parse from 'unstring'\n\n/**\n * Update the state of this tab when another tab emits a storage event\n * \n * @param cb callback handed the parsed value of the namespace\n * @param defaultValue T\n * @returns void\n */\nconst receiveStorageEvent = cb => e => {\n  if(typeof cb !== 'function') return \n   \n  if(!e.newValue) {\n    return \n  }  \n\n  const newValue = parse(e.newValue)\n  cb(newValue)\n}\n\nexport default receiveStorageEvent","import parse from 'unstring'\nimport isAbsent from './isAbsent'\n\n/**\n * Read an namespace in localStorage or a nested value at that namespace\n * \n * @param {string} namespace root key of localStorage\n * @param {unknown} value parsed item value \n * @param {(string | number)[] | undefined} path Ramda Path to nested prop \n */\nconst read = namespace => pathToProp => {\n  const stringifiedNamespace = localStorage.getItem(namespace) || ''\n  if(isAbsent(stringifiedNamespace)) return undefined\n  const parsedNamespace = parse(stringifiedNamespace)\n  return isAbsent(pathToProp) ? parsedNamespace : path(pathToProp, parsedNamespace)\n}\n\nexport default read","import { \n  anyPass, \n  isEmpty, \n  isNil\n} from 'ramda'\n\nexport default anyPass([isEmpty, isNil])\n","import emitStorageEvent from '../emitStorageEvent'\nimport read from './read'\nimport update from './update'\n\nimport isAbsent from './isAbsent'\nimport { dissocPath } from 'ramda'\n\n/**\n * Remove a namespace from localStorage or a nested value at that namespace\n * \n * @param {string} namespace root key of localStorage\n * @param {(string | number)[] | undefined} path Ramda Path to nested prop  \n */\nconst unset = namespace => pathToProp => {\n  if(isAbsent(pathToProp)) {\n    localStorage.removeItem(namespace)\n    emitStorageEvent(namespace, null)\n    return \n  }\n  const namespaceValue = read(namespace)()\n  const newNamespaceValue = dissocPath(pathToProp, namespaceValue)\n  update(namespace)(newNamespaceValue)\n}\n\nexport default unset","/*\ntype StorageEventConfig = {\n  storageArea: Storage \n  url: string \n  key: string \n  newValue?: string \n}\n*/\n\nconst emitStorageEvent = (key, stringifiedValue) => {\n  const config = {\n    storageArea: window.localStorage,\n    url: window.location.href,\n    key,\n    newValue: stringifiedValue\n  }\n  \n  const storageEvent = new StorageEvent(\"storage\", config)\n  window.dispatchEvent(storageEvent)\n}\n\nexport default emitStorageEvent","import emitStorageEvent from '../emitStorageEvent'\nimport read from './read'\nimport { isNil, lensPath, set } from 'ramda'\n\nconst stringify = value => {\n  try {\n    const stringifiedValue = JSON.stringify(value)\n    return stringifiedValue\n  } catch(e) {\n    return undefined\n  }\n}\n\n/**\n * Set an namespace in localStorage or a nested value at that namespace\n * \n * Emit the update to other tabs \n * \n * @param {string} namespace root key of localStorage\n * @param {unknown} value parsed item value \n * @param {(string | number)[] | undefined} path Ramda Path to nested prop \n */\nconst update = namespace => (value, path) => {\n  const currentNamespace = read(namespace)()\n  const updatedNamespaceValue = isNil(path) ? value : set(lensPath(path), value, currentNamespace)\n  const stringifiedNamespace = stringify(updatedNamespaceValue)\n  localStorage.setItem(namespace, stringifiedNamespace)\n  emitStorageEvent(namespace, stringifiedNamespace)\n}\n\nexport default update"],"names":[],"version":3,"file":"index.js.map","sourceRoot":"../"}